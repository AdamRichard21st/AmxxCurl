#ifndef _EXECUTION_QUEUE_INTERFACE_H_
#define _EXECUTION_QUEUE_INTERFACE_H_

#include <condition_variable>

// Класс реализующий этот интерфейс должен представлять синхронизированную очередь исполнения потоков (что бы это ни значило).
//
// Каждый поток, который требуется синхронизировать с главным потоком, должен вызвать WaitSignal, после этого текущий поток встанет в ожидание сигнала от главного потока.
// Главный поток может вызвать ExecuteAll для поочередного (!) исполнения всех потоков стоящих в ожидании, причем в том порядке в котором они вставали в ожидание.
// Главный поток продолжит работу только тогда, когда все потоки из очереди будут исполнены.
// Посе того как поток из очереди отработал он сможет синхронизироваться с этой же очередью только после исполнения всех остальных потоков из этой самой очереди (там тип мьютекс в ExecuteAll и WaitSignal)
//
// Сторого рекомендую использовать совместно с ExecutionQueueInterface класс SignalExecutor.
class ExecutionQueueInterface
{
public:
    // Ставит текущий поток в ожидание сигнала, оповещение происходит через condition_variable и notify
    virtual void WaitSignal(std::condition_variable& condition_variable, bool& notify) = 0;

    // Поток должен оповестить очередь о завершении выполнения критического участка
    virtual void Executed() = 0;

    // Исполнить всю потоки по очереди
    virtual void ExecuteAll() = 0;

    virtual ~ExecutionQueueInterface() {}
};

#endif // !_EXECUTION_QUEUE_INTERFACE_H_